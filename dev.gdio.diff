diff --git a/Makefile b/Makefile
--- ./Makefile
+++ ./Makefile
@@ -44,6 +44,8 @@ define build_package
 $1-$2:
 	cargo build --release --features=$1 -p avante-$2
 	cp target/release/libavante_$(shell echo $2 | tr - _).$(EXT) $(BUILD_DIR)/avante_$(shell echo $2 | tr - _).$(EXT)
+	@mkdir -p lua/avante
+	cp $(BUILD_DIR)/avante_$(shell echo $2 | tr - _).$(EXT) lua/avante/
 endef
 
 define build_targets
diff --git a/lua/avante/config.lua b/lua/avante/config.lua
--- ./lua/avante/config.lua
+++ ./lua/avante/config.lua
@@ -47,10 +47,10 @@ M.defaults = {
   ---@type AvanteSupportedProvider
   claude = {
       endpoint = "https://api.anthropic.com",
-    model = "claude-3-5-sonnet-20241022",
+      model = "claude-3-haiku-20240307",
       timeout = 30000, -- Timeout in milliseconds
       temperature = 0,
-    max_tokens = 8000,
+      max_tokens = 4096,
     },
   ---@type AvanteSupportedProvider
   gemini = {
diff --git a/lua/avante/llm.lua b/lua/avante/llm.lua
--- ./lua/avante/llm.lua
+++ ./lua/avante/llm.lua
@@ -8,6 +8,7 @@ local Utils = require("avante.utils")
 local Config = require("avante.config")
 local Path = require("avante.path")
 local P = require("avante.providers")
+local Logger = require("avante.logger")
 
 ---@class avante.LLM
 local M = {}
@@ -114,16 +115,21 @@ M._stream = function(opts, Provider)
 
   ---@param line string
   local function parse_stream_data(line)
+    Logger.debug_response({ event = "stream_data", line = line })
     local event = line:match("^event: (.+)$")
     if event then
       current_event_state = event
       return
     end
     local data_match = line:match("^data: (.+)$")
-    if data_match then Provider.parse_response(data_match, current_event_state, handler_opts) end
+    if data_match then
+      Logger.debug_response({ event = "data_match", data = data_match })
+      Provider.parse_response(data_match, current_event_state, handler_opts)
+    end
   end
 
   local function parse_response_without_stream(data)
+    Logger.debug_response({ event = "response_without_stream", data = data })
     Provider.parse_response_without_stream(data, current_event_state, handler_opts)
   end
 
@@ -149,74 +155,93 @@ M._stream = function(opts, Provider)
     body = curl_body_file,
     stream = function(err, data, _)
       if err then
+        Logger.debug_response({ event = "curl_stream_error", error = err })
         completed = true
         opts.on_complete(err)
         return
       end
-      if not data then return end
+      
+      if not data then 
+        Logger.debug_response({ event = "curl_stream_no_data" })
+        return 
+      end
+      
+      Logger.debug_response({ 
+        event = "curl_stream_data", 
+        data = data,
+        data_type = type(data),
+        data_length = #data
+      })
+      
       vim.schedule(function()
         if Config.options[Config.provider] == nil and Provider.parse_stream_data ~= nil then
-          if Provider.parse_response ~= nil then
-            Utils.warn(
-              "parse_stream_data and parse_response are mutually exclusive, and thus parse_response will be ignored. Make sure that you handle the incoming data correctly.",
-              { once = true }
-            )
-          end
+          Logger.debug_response({ event = "using_provider_direct", provider = Config.provider })
           Provider.parse_stream_data(data, handler_opts)
         else
           if Provider.parse_stream_data ~= nil then
+            Logger.debug_response({ event = "using_provider_config", provider = Config.provider })
             Provider.parse_stream_data(data, handler_opts)
           else
+            Logger.debug_response({ event = "using_local_parse" })
             parse_stream_data(data)
           end
         end
       end)
     end,
-    on_error = function(err)
-      if err.exit == 23 then
-        local xdg_runtime_dir = os.getenv("XDG_RUNTIME_DIR")
-        if not xdg_runtime_dir or fn.isdirectory(xdg_runtime_dir) == 0 then
-          Utils.error(
-            "$XDG_RUNTIME_DIR="
-              .. xdg_runtime_dir
-              .. " is set but does not exist. curl could not write output. Please make sure it exists, or unset.",
-            { title = "Avante" }
-          )
-        elseif not uv.fs_access(xdg_runtime_dir, "w") then
-          Utils.error(
-            "$XDG_RUNTIME_DIR="
-              .. xdg_runtime_dir
-              .. " exists but is not writable. curl could not write output. Please make sure it is writable, or unset.",
-            { title = "Avante" }
-          )
-        end
-      end
-      active_job = nil
-      completed = true
-      cleanup()
-      opts.on_complete(nil)
-    end,
     callback = function(result)
+      Logger.debug_response({ 
+        event = "curl_callback", 
+        status = result.status,
+        headers = result.headers,
+        body_size = result.body and #result.body or 0,
+        body = result.body
+      })
+      
       active_job = nil
       cleanup()
+      
       if result.status >= 400 then
+        local error_body = result.body
+        if type(result.body) == "string" then
+          local ok, decoded = pcall(vim.json.decode, result.body)
+          if ok then
+            error_body = decoded
+          end
+        end
+        
+        Logger.debug_response({ 
+          event = "request_error", 
+          status = result.status, 
+          error = error_body,
+          raw_body = result.body
+        })
+        
         if Provider.on_error then
           Provider.on_error(result)
         else
-          Utils.error("API request failed with status " .. result.status, { once = true, title = "Avante" })
+          Utils.error(string.format("API request failed with status %d. Error: %s", 
+            result.status, 
+            vim.inspect(error_body)
+          ), { once = true, title = "Avante" })
         end
+        
         vim.schedule(function()
           if not completed then
             completed = true
-            opts.on_complete(
-              "API request failed with status " .. result.status .. ". Body: " .. vim.inspect(result.body)
-            )
+            opts.on_complete(string.format("API request failed with status %d. Error: %s",
+              result.status,
+              vim.inspect(error_body)
+            ))
           end
         end)
       end
 
-      -- If stream is not enabled, then handle the response here
       if spec.body.stream == false and result.status == 200 then
+        Logger.debug_response({ 
+          event = "non_stream_success", 
+          body = result.body,
+          body_type = type(result.body)
+        })
         vim.schedule(function()
           completed = true
           parse_response_without_stream(result.body)
diff --git a/lua/avante/providers/claude.lua b/lua/avante/providers/claude.lua
--- ./lua/avante/providers/claude.lua
+++ ./lua/avante/providers/claude.lua
@@ -1,6 +1,7 @@
 local Utils = require("avante.utils")
 local Clipboard = require("avante.clipboard")
 local P = require("avante.providers")
+local Logger = require("avante.logger")
 
 ---@class AvanteClaudeBaseMessage
 ---@field cache_control {type: "ephemeral"}?
@@ -78,15 +79,44 @@ M.parse_messages = function(opts)
 end
 
 M.parse_response = function(data_stream, event_state, opts)
+  Logger.debug_response({ event = "parse_response_start", state = event_state, data = data_stream })
+  
   if event_state == "content_block_delta" then
     local ok, json = pcall(vim.json.decode, data_stream)
-    if not ok then return end
+    Logger.debug_response({ event = "json_decode_result", success = ok, data = json })
+    
+    if not ok then 
+      Logger.debug_response({ event = "json_decode_failed", error = json })
+      return 
+    end
+    
+    -- 安全地检查 JSON 结构
+    if json and json.delta and json.delta.text then
       opts.on_chunk(json.delta.text)
+    else
+      Logger.debug_response({ 
+        event = "unexpected_json_structure", 
+        json = json,
+        message = "Expected json.delta.text structure not found"
+      })
+    end
   elseif event_state == "message_stop" then
+    Logger.debug_response({ event = "message_stop_received" })
     opts.on_complete(nil)
     return
   elseif event_state == "error" then
-    opts.on_complete(vim.json.decode(data_stream))
+    local ok, json = pcall(vim.json.decode, data_stream)
+    Logger.debug_response({ 
+      event = "error_received", 
+      success = ok, 
+      data = json,
+      raw_data = data_stream 
+    })
+    if ok then
+      opts.on_complete(json)
+    else
+      opts.on_complete(data_stream)
+    end
   end
 end
 
@@ -106,12 +136,8 @@ M.parse_curl_args = function(provider, prompt_opts)
 
   local messages = M.parse_messages(prompt_opts)
 
-  return {
-    url = Utils.url_join(base.endpoint, "/v1/messages"),
-    proxy = base.proxy,
-    insecure = base.allow_insecure,
-    headers = headers,
-    body = vim.tbl_deep_extend("force", {
+  local url = Utils.trim(base.endpoint, { suffix = "/" }) .. "/v1/messages"
+  local body = vim.tbl_deep_extend("force", {
       model = base.model,
       system = {
         {
@@ -122,11 +148,22 @@ M.parse_curl_args = function(provider, prompt_opts)
       },
       messages = messages,
       stream = true,
-    }, body_opts),
+  }, body_opts)
+
+  Logger.debug_request(url, headers, body)
+
+  return {
+    url = url,
+    proxy = base.proxy,
+    insecure = base.allow_insecure,
+    headers = headers,
+    body = body,
   }
 end
 
 M.on_error = function(result)
+  Logger.debug_response(result)
+
   if not result.body then
     return Utils.error("API request failed with status " .. result.status, { once = true, title = "Avante" })
   end
@@ -148,4 +185,26 @@ M.on_error = function(result)
   Utils.error(error_msg, { once = true, title = "Avante" })
 end
 
+M.parse_stream_data = function(data, opts)
+  Logger.debug_response({ event = "stream_data_received", data = data })
+  local lines = vim.split(data, "\n")
+  for _, line in ipairs(lines) do
+    if line ~= "" then
+      local event = line:match("^event: (.+)$")
+      if event then
+        Logger.debug_response({ event = "event_line", event_type = event })
+        M.parse_response(event, event, opts)
+      else
+        local data_match = line:match("^data: (.+)$")
+        if data_match then
+          Logger.debug_response({ event = "data_line", data = data_match })
+          M.parse_response(data_match, "content_block_delta", opts)
+        else
+          Logger.debug_response({ event = "unmatched_line", line = line })
+        end
+      end
+    end
+  end
+end
+
 return M
diff --git a/lua/avante/sidebar.lua b/lua/avante/sidebar.lua
--- ./lua/avante/sidebar.lua
+++ ./lua/avante/sidebar.lua
@@ -1730,16 +1730,6 @@ function Sidebar:render(opts)
     xpcall(function() api.nvim_buf_set_name(self.result.bufnr, RESULT_BUF_NAME) end, function(_) end)
   end)
 
-  self.result:map("n", "q", function()
-    Llm.cancel_inflight_request()
-    self:close()
-  end)
-
-  self.result:map("n", "<Esc>", function()
-    Llm.cancel_inflight_request()
-    self:close()
-  end)
-
   self:create_input(opts)
 
   self:update_content_with_history(chat_history)
